function [newData1 varargout] = ImportNanoMuxFile(fileName)
% This function reads in the file generated by the NucleVolt control
% software written by Austin Goodwin.

%  The file is a tab delimitted text file with an Excell file extension.
%  The file must be opened in Excell and saved as a tab delimitted text
%  file in order for this function to work robustly.

%  This function returns the contents of the files in multiple ways.
% newData1 is a structure which holds multiple arrays.
%   newData1.textdata:  Holds the entire contents of the file as a string cell array.
%                       
%   newData1.formattedData: Is a 1x4 cell array of arrays.  
%       newData1.formattedData{1,1} is a {numpoints x 1} array of "cells"  of strings.  Holds the
%                                   time stamp string
%
%       newData1.formattedData{1,2} is a  {numpoints x 1}  array of double.  Holds the
%                                   time in seconds of the measurement.
%
%       newData1.formattedData{1,3} is a  {numpoints x 4}  array of "cells" of string.  Holds the
%                                   comments.
%
%       newData1.formattedData{1,4} is a  {numpoints x numDataCols}  array of double.  Holds the
%                                   actual measurment data.
%
%   newData1.reShapedData:  Holds the numeric measurement data rearranged
%                           such that it is layed out in the matrix the way
%                           it exists on the chip.  (ie
%                           reShapedData(row1,col1,:) is data from row1,
%                           col1 on the chip)

%%  Define needed parameters
DELIMITER = '\t';
HEADERLINE = 9;
HEADERLINE = 8;         %File format changed slightly 2011_07_14
ROW_COL_LINE = 6;
FIRST_VALID_COLUMN = 7;       %% In text cell array
NUM_ROWS = 32;
%NUM_ROWS = 64;          %Changed for new layout with single layer

IS_SINGLE_LAYER_CHIP = 1;

%%  Get, or generate the filename


if (nargin ~= 1)   
    [fname, fpath]= uigetfile('*.txt', 'Select Necleovolt file');
    temp = fname;
    fname = fullfile(fpath,fname);

else
    fname = fileName;
    temp = fname;
end


%% Actually read in the data

% Import the file.  Not a robust method to read in files, but it at least
% gives me the number of columns of data in the file.  This info is needed
% to implement the more robust file reading meathod.
temp2 = importdata(fname, DELIMITER, HEADERLINE);
newData1.textdata = temp2.textdata;
clear temp2;

%After more testing with data files, I learned that importdata() freaks
% out when there is text in the cols 3 - 7.  Need to do this read manually.
% The following code re-reads the data in using a more robust method.

[numrows numCols] = size(newData1.textdata);
formatString = [repmat('%q',1,numCols)];
formatString2 = ['%q' '%n' repmat('%q', 1, 4) repmat('%n', 1, numCols-6)];
fid = fopen(fname);
bufsize = 1e6;
%Read entire contents of file as string cell array
textData = textscan(fid,formatString,'delimiter',DELIMITER,...
                'bufsize', bufsize, 'headerlines',0, 'CollectOutput', true);
aa=fseek(fid,0,'bof');
%Read in numeric data region with formatting.  Capture text in cols 3-7
formattedData = textscan(fid,formatString2,'delimiter',DELIMITER,...
                'bufsize', bufsize, 'headerlines',HEADERLINE, 'CollectOutput', true);
fclose(fid);

%Stuff data into previous format so that I dont have to change functions
%that call this one.
newData1.textdata = textData{:};


%% Reorganize the  data

% Reorganize excell data so that it is laid out in memory the same way
% its laid out on the chip.  (ie. row1 col1 of data is row1,col1 on chip
% Data will be laid out in memory as follows: reShapedData (row,col,time)

%Reorganize data by row and col and stuff into data cube.
% read ROW_COL_LINE text line to find max row and col.  expected text
% format is (Cxx,Ryy)


% Assume I know the num rows on the chip

if (IS_SINGLE_LAYER_CHIP)
    minSensorRow = 1;  %temp code
    maxSensorRow = 32; %temp Code
    sensorCols = [1, 2];

    newData1.reShapedData = zeros(32,2,size(formattedData{1,4},1)); 
    for cc = 1:64 %col number of data as laid out in file
       tempVector = formattedData{1,4}(:,cc);

       if (cc<=16)
           rowIndex = cc;
           colIndex = 1;
           newData1.reShapedData(rowIndex,colIndex,:)=tempVector;

       elseif ((cc>16)&&(cc<=32))
           rowIndex = cc - 16;
           colIndex = 2;
           newData1.reShapedData(rowIndex,colIndex,:)=tempVector;    
       elseif ((cc>32)&&(cc<=48))
           rowIndex = cc - 16;
           colIndex = 1;
           newData1.reShapedData(rowIndex,colIndex,:)=tempVector; 
       elseif ((cc>48)&&(cc<=64))  %%TEMP CODE.  SELECTED EXTRA ROW WHEN
       %TESTING SINGLE LAYER CHIP.  DELETE NEXT TO LINES OF CODE WHEN DONE
       %WITH THESE DATA SETS
           rowIndex = cc - 32;
       %elseif ((cc>49)&&(cc<=65))  %
       %    rowIndex = cc - 33;
           colIndex = 2;
           newData1.reShapedData(rowIndex,colIndex,:)=tempVector; 
       end 
    end
    
else
    numSensorElementsInData = size(formattedData{1,4},2);
    numCols = round(numSensorElementsInData/NUM_ROWS);
    numTimePoints = size(formattedData{1,4},1);
    newData1.reShapedData = reshape(formattedData{1,4}', [numCols,NUM_ROWS,numTimePoints]); %Take 1D vector and reshape into 3D matix
    newData1.reShapedData = permute(newData1.reShapedData,[2,1,3]); % %shuffle matrix dimensions to put rows as first dimension
    
end


newData1.formattedData = formattedData;

varargout = {temp};


